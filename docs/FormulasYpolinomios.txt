-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sistema certificado de decisión proposicional basado en polinomios.
--   
--   Sistema certificado de decisión proposicional basado en polinomios.
@package FormulasYpolinomios
@version 0.1.0.0


-- | Código correspondiente al artículo <a>Sistema certificado de decisión
--   proposicional basado en polinomios</a> presentado en el CLAI2009
--   (Workshop on Computational Logic and Artificial Intelligence).
module CLAI2009

-- | Los símbolos proposicionales se representan por cadenas.
type SimboloProposicional = String

-- | FProp es el tipo de las fórmulas proposicionales definidas por
--   
--   <ul>
--   <li>T y F son fórmulas</li>
--   <li>Si A es una fórmula, también lo es ¬A.</li>
--   <li>Si A y B son fórmulas, entonces (A ∧ B), (A ∨ B), (A → B) y (A ↔
--   B) también lo son.</li>
--   </ul>
data FProp
T :: FProp
F :: FProp
Atom :: SimboloProposicional -> FProp
Neg :: FProp -> FProp
Conj :: FProp -> FProp -> FProp
Disj :: FProp -> FProp -> FProp
Impl :: FProp -> FProp -> FProp
Equi :: FProp -> FProp -> FProp

-- | Declaración del procedimiento de escritura de fórmulas.

-- | Ejemplo de fórmulas.
p :: FProp

-- | Ejemplo de fórmulas.
q :: FProp

-- | Ejemplo de fórmulas.
r :: FProp

-- | (no f) es la negación de f
no :: FProp -> FProp

-- | (f ∨ g) es la disyunción de f y g.
(∨) :: FProp -> FProp -> FProp
infixr 5 ∨

-- | (f ∧ g) es la conjunción de f y g
(∧) :: FProp -> FProp -> FProp
infixr 4 ∧

-- | (f → g) es la implicación de f a g
(→) :: FProp -> FProp -> FProp
infixr 3 →

-- | (f ↔ g) es la equivalencia entre f y g
(↔) :: FProp -> FProp -> FProp
infixr 2 ↔

-- | FProp es una instancia de Arbitrary. Por ejemplo,
--   
--   <pre>
--   &gt; sample (arbitrary :: Gen FProp)
--   T
--   (no p ∨ (F ∧ F))
--   no r
--   ((q → (T ∧ s)) → F)
--   ((((T → p) ∧ s) → no (q → q)) → s)
--   ((no (r ∨ r) → no (p → s)) ∧ ((p ↔ T) ∧ no (s ↔ F)))
--   (F → s)
--   no no p
--   </pre>

-- | Las interpretaciones son listas de fórmulas atómicas. Las fórmulas de
--   las interpretaciones se suponen verdaderas y las restantes fórmulas
--   atómicas se suponen falsas.
type Interpretacion = [FProp]

-- | (significado f i) es el significado de la fórmula f en la
--   interprestación i. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; significado ((p ∨ q) ∧ ((no q) ∨ r)) [r]
--   False
--   
--   &gt;&gt;&gt; significado ((p ∨ q) ∧ ((no q) ∨ r)) [p,r]
--   True
--   </pre>
significado :: FProp -> Interpretacion -> Bool

-- | (simbolosPropForm f) es el conjunto formado por todos los símbolos
--   proposicionales que aparecen en f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; simbolosPropForm (p ∧ q → p)
--   [p,q]
--   </pre>
simbolosPropForm :: FProp -> [FProp]

-- | (interpretacionesForm f) es la lista de todas las interpretaciones de
--   la fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; interpretacionesForm (p ∧ q → p)
--   [[],[p],[q],[p,q]]
--   </pre>
interpretacionesForm :: FProp -> [Interpretacion]

-- | (esModeloFormula i f) se verifica si la interpretación i es un modelo
--   de la fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esModeloFormula [r]   ((p ∨ q) ∧ ((no q) ∨ r))
--   False
--   
--   &gt;&gt;&gt; esModeloFormula [p,r] ((p ∨ q) ∧ ((no q) ∨ r))
--   True
--   </pre>
esModeloFormula :: Interpretacion -> FProp -> Bool

-- | (modelosFormula f) es la lista de todas las interpretaciones de la
--   fórmula f que son modelo de F. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; modelosFormula ((p ∨ q) ∧ ((no q) ∨ r))
--   [[p],[p,r],[q,r],[p,q,r]]
--   </pre>
modelosFormula :: FProp -> [Interpretacion]

-- | (esValida f) se verifica si la fórmula f es válida. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esValida (p → p)
--   True
--   
--   &gt;&gt;&gt; esValida (p → q)
--   False
--   
--   &gt;&gt;&gt; esValida ((p → q) ∨ (q → p))
--   True
--   </pre>
esValida :: FProp -> Bool

-- | (prop_esValida f) se verifica si las siguiente condiciones son
--   equivalentes:
--   
--   <ul>
--   <li>f es válida</li>
--   <li>f es consecuencia del conjunto vacío.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_esValida
--   +++ OK, passed 100 tests.
--   </pre>
prop_esValida :: FProp -> Bool

-- | (esInsatisfacible f) se verifica si la fórmula f es insatisfacible.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esInsatisfacible (p ∧ (no p))
--   True
--   
--   &gt;&gt;&gt; esInsatisfacible ((p → q) ∧ (q → r))
--   False
--   </pre>
esInsatisfacible :: FProp -> Bool

-- | (esSatisfacible f) se verifica si f es satisfacible. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esSatisfacible (p ∧ (no p))
--   False
--   
--   &gt;&gt;&gt; esSatisfacible ((p → q) ∧ (q → r))
--   True
--   </pre>
esSatisfacible :: FProp -> Bool

-- | (unionGeneral x) es la unión de los conjuntos de la lista de conjuntos
--   x. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; unionGeneral []
--   []
--   
--   &gt;&gt;&gt; unionGeneral [[1]]
--   [1]
--   
--   &gt;&gt;&gt; unionGeneral [[1],[1,2],[2,3]]
--   [1,2,3]
--   </pre>
unionGeneral :: Eq a => [[a]] -> [a]

-- | (simbolosPropConj s) es el conjunto de los símbolos proposiciones de
--   s. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; simbolosPropConj [p ∧ q → r, p → r]
--   [p,q,r]
--   </pre>
simbolosPropConj :: [FProp] -> [FProp]

-- | (interpretacionesConjunto s) es la lista de las interpretaciones de s.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; interpretacionesConjunto [p → q, q → r]
--   [[],[p],[q],[p,q],[r],[p,r],[q,r],[p,q,r]]
--   </pre>
interpretacionesConjunto :: [FProp] -> [Interpretacion]

-- | (esModeloConjunto i s) se verifica si i es modelo de s. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esModeloConjunto [p,r] [(p ∨ q) ∧ ((no q) ∨ r), q → r]
--   True
--   
--   &gt;&gt;&gt; esModeloConjunto [p,r] [(p ∨ q) ∧ ((no q) ∨ r), r → q]
--   False
--   </pre>
esModeloConjunto :: Interpretacion -> [FProp] -> Bool

-- | (modelosConjunto s) es la lista de modelos del conjunto s. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; modelosConjunto [(p ∨ q) ∧ ((no q) ∨ r), q → r]
--   [[p],[p,r],[q,r],[p,q,r]]
--   
--   &gt;&gt;&gt; modelosConjunto [(p ∨ q) ∧ ((no q) ∨ r), r → q]
--   [[p],[q,r],[p,q,r]]
--   </pre>
modelosConjunto :: [FProp] -> [Interpretacion]

-- | (esConsistente s) se verifica si s es consistente. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esConsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r]
--   True
--   
--   &gt;&gt;&gt; esConsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r, no r]
--   False
--   </pre>
esConsistente :: [FProp] -> Bool

-- | (esInconsistente s) se verifica si s es inconsistente. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esInconsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r]
--   False
--   
--   &gt;&gt;&gt; esInconsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r, no r]
--   True
--   </pre>
esInconsistente :: [FProp] -> Bool

-- | (esConsecuencia s f) se verifica si f es consecuencia de s. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esConsecuencia [p → q, q → r] (p → r)
--   True
--   
--   &gt;&gt;&gt; esConsecuencia [p] (p ∧ q)
--   False
--   </pre>
esConsecuencia :: [FProp] -> FProp -> Bool

-- | (prop_esConsecuencia s f) verifica que son equivalentes:
--   
--   <ul>
--   <li>f es consecuencia de s</li>
--   <li>s ∪ {¬f} es inconsistente</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_esConsecuencia
--   +++ OK, passed 100 tests.
--   </pre>
prop_esConsecuencia :: [FProp] -> FProp -> Bool

-- | (equivalentes f g) se verifica si las fórmulas f y g son equivalentes.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; equivalentes (p → q) (no p ∨ q)
--   True
--   </pre>
equivalentes :: FProp -> FProp -> Bool

-- | <a>caracteres</a> es un generador de caracteres de letras minúsculas.
--   Por ejemplo,
--   
--   <pre>
--   &gt; sample caracteres
--   <tt>x</tt>
--   <tt>n</tt>
--   <a>r</a>
--   </pre>
caracteres :: Gen Char

-- | Las variables se representan por cadenas.
type Variable = String

-- | <a>variables</a> es un generador de variables de longitud 1 ó 2. Por
--   ejemplo,
--   
--   <pre>
--   &gt; sample variables
--   "h"
--   "yi"
--   "m"
--   </pre>
variables :: Gen String

-- | variables' es un generador de variables de longitud aleatoria, pero no
--   cero. Por ejemplo,
--   
--   <pre>
--   &gt; sample variables'
--   "o"
--   "rte"
--   "tmzeu"
--   </pre>
variables' :: Gen String

-- | Los monomios son productos de variables distintas y se representan por
--   listas ordenadas de variables distintas.
data Monomio
M :: [Variable] -> Monomio

-- | Los monomios se escribe incercalando el * entre sus variables. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; M []
--   1
--   
--   &gt;&gt;&gt; M ["x"]
--   x
--   
--   &gt;&gt;&gt; M ["xy","z","u"]
--   xy*z*u
--   </pre>

-- | El monomio correspondiente a la lista vacía es el 1 (elemento neutro
--   del producto).
--   
--   <pre>
--   &gt;&gt;&gt; mUno
--   1
--   </pre>
mUno :: Monomio

-- | La condición de que las variables sean distintas y ordenadas no se
--   recoge en la definición del tipo de dato. Por ello se define el
--   siguiente reconocedor de monomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esMonomio (M ["x1","x3","z"])
--   True
--   
--   &gt;&gt;&gt; esMonomio (M ["x5","x3","z"])
--   False
--   
--   &gt;&gt;&gt; esMonomio (M ["x1","x1","z"])
--   False
--   </pre>
esMonomio :: Monomio -> Bool

-- | (monomiosN n) es un generador de monomios con el número de variables
--   entre 0 y n. Por ejemplo,
--   
--   <pre>
--   &gt; sample (monomiosN 3)
--   1
--   s
--   e*t
--   hx*w*xn
--   &gt; sample (monomiosN 10)
--   at*b*dy*fq*gv*mx*y*z
--   a*cm*d*f*h*wf*z
--   b*dw*wx*x*y*z
--   </pre>
monomiosN :: Int -> Gen Monomio

-- | monomios es un generador de monomios con el número de variables entre
--   0 y 3. Por ejemplo,
--   
--   <pre>
--   &gt; sample monomios
--   nd*q
--   e
--   1
--   </pre>
monomios :: Gen Monomio

-- | monomios' es un generador de monomios con un número aleatorio de
--   variables. Por ejemplo,
--   
--   <pre>
--   &gt; sample monomios'
--   1
--   kl*o*u
--   bm*d*k*mk
--   </pre>
monomios' :: Gen Monomio

-- | prop_MonomiosGeneraMonomios comprueba que el generador de monomios
--   genera monomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_MonomiosGeneraMonomios
--   +++ OK, passed 100 tests.
--   </pre>
prop_MonomiosGeneraMonomios :: Monomio -> Bool

-- | Los monomios son arbitrarios.

-- | Los polinomios son sumas de monomios distintos y ordenados y se
--   representan por listas ordenadas de monomios distintos,
data Polinomio
P :: [Monomio] -> Polinomio

-- | Los polinomios se escribe incercalando el + entre sus monomios. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; P [M ["xy","z","u"], M ["p","q"]]
--   xy*z*u+p*q
--   
--   &gt;&gt;&gt; P [M ["xy","z","u"]]
--   xy*z*u
--   
--   &gt;&gt;&gt; P [M []]
--   1
--   
--   &gt;&gt;&gt; P []
--   0
--   </pre>

-- | El polinomio correspondiente a la lista vacía es el 0 (elemento neutro
--   de la suma). Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; cero
--   0
--   </pre>
cero :: Polinomio

-- | El polinomio 1 es el polinomio cuyo único elemento es el monomio uno.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; uno
--   1
--   </pre>
uno :: Polinomio

-- | La condición de que los monomios sean distintos y ordenados no se
--   recoge en la definición del tipo de dato. Por ello se define el
--   siguiente reconocedor de polinomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esPolinomio (P [M ["a","b","c"], M ["x","y"]])
--   True
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["x","y"], M ["a","c","d"]])
--   False
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["x","y"], M ["a","d","c"]])
--   False
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["x","y"], M ["a","a","c"]])
--   False
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["x","y"], M ["x","y"], M ["a","c","d"]])
--   False
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["a","a","c"], M ["x","y"]])
--   False
--   </pre>
esPolinomio :: Polinomio -> Bool

-- | (polinomiosN n) es un generador de polinomios con el número de
--   monomios entre 0 y n. Por ejemplo,
--   
--   <pre>
--   &gt; sample (polinomiosN 3)
--   0
--   pp*sa
--   gn*nf*zg
--   &gt; sample (polinomiosN 10)
--   1+b*j+gw*w*zm+j*ox+l*q*qz+ly*p*r+m+q*zy
--   iz
--   1+d+dy+jd*l+lr+w
--   </pre>
polinomiosN :: Int -> Gen Polinomio

-- | polinomios es un generador de polinomios con el número de monomios
--   entre 0 y 3. Por ejemplo,
--   
--   <pre>
--   &gt; sample monomios
--   nd*q
--   e
--   1
--   </pre>
polinomios :: Gen Polinomio

-- | polinomios' es un generador de polinomios con un número aleatorio de
--   monomios. Por ejemplo,
--   
--   <pre>
--   &gt; sample polinomios'
--   0
--   1
--   f*m*on*tr*ue*x
--   ct*d*ds*gy*ps*s*y
--   </pre>
polinomios' :: Gen Polinomio

-- | prop_PolinomiosGeneraPolinomios comprueba que el generador de
--   polinomios genera polinomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_PolinomiosGeneraPolinomios
--   +++ OK, passed 100 tests.
--   </pre>
prop_PolinomiosGeneraPolinomios :: Polinomio -> Bool

-- | Los polinomios son arbitrarios.

-- | Para facilitar la escritura, se hace Polinomio una instancia de la
--   clase Num. Las funciones suma y producto se definen a continuación.

-- | (suma p q) es la suma de los polinomios p y q. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; suma (P [M ["x"], M ["y"]]) (P [M ["y"], M ["z"]])
--   x+z
--   
--   &gt;&gt;&gt; suma (P [M ["x"], M ["y"]]) (P [M ["a"], M ["z"]])
--   a+x+y+z
--   </pre>
suma :: Polinomio -> Polinomio -> Polinomio

-- | (sumaAux xs ys) es la lista de las sumas de los monomios de xs e ys.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; sumaAux [M ["x"], M ["y"]] [M ["y"], M ["z"]]
--   [x,z]
--   
--   &gt;&gt;&gt; sumaAux [M ["x"], M ["y"]] [M ["a"], M ["z"]]
--   [a,x,y,z]
--   </pre>
sumaAux :: [Monomio] -> [Monomio] -> [Monomio]

-- | Comprueba que la suma de polinomios está bien definida.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_bien_definida
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_bien_definida :: Polinomio -> Polinomio -> Bool

-- | Comprueba que la suma de polinomios es conmutativa.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_conmutativa
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_conmutativa :: Polinomio -> Polinomio -> Bool

-- | Comprueba que la suma de polinomios es conmutativa.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_asociativa
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_asociativa :: Polinomio -> Polinomio -> Polinomio -> Bool

-- | Comprueba que cero es el elemento neutro de la suma de polinomios.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_neutro
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_neutro :: Polinomio -> Bool

-- | Comprueba que cada elemento es su simétrico en la suma de polinomios.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_simetrico
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_simetrico :: Polinomio -> Bool

-- | (productoMM m1 m2) es el producto de los monomios m1 y m2. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; productoMM (M ["x","y"]) (M ["y","z"])
--   x*y*z
--   </pre>
productoMM :: Monomio -> Monomio -> Monomio

-- | (productoMP m p) es el producto del monomio m por el polinomio p. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; productoMP (M ["x","y"]) (P [M ["a"], M ["y","z"]])
--   a*x*y+x*y*z
--   </pre>
productoMP :: Monomio -> Polinomio -> Polinomio

-- | (producto p1 p2) es el producto de los polinomios p1 y p2. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; producto (P [M ["x","y"], M ["z"]]) (P [M ["a"], M ["y","z"]])
--   a*x*y+a*z+x*y*z+y*z
--   
--   &gt;&gt;&gt; producto (P [M ["x","y"], M ["z"]]) (P [M ["x"], M ["y","z"]])
--   x*y+x*y*z+x*z+y*z
--   
--   &gt;&gt;&gt; producto (P [M ["x"], M ["y"]]) (P [M ["x"], M ["y"]])
--   x+y
--   </pre>
producto :: Polinomio -> Polinomio -> Polinomio

-- | Comprueba que el producto de polinomios está bien definido.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_prod_bien_definido
--   +++ OK, passed 100 tests.
--   </pre>
prop_prod_bien_definido :: Polinomio -> Polinomio -> Bool

-- | Comprueba que el producto de polinomios es conmutativo
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_prod_conmutativa
--   +++ OK, passed 100 tests.
--   </pre>
prop_prod_conmutativa :: Polinomio -> Polinomio -> Bool

-- | Comprueba que el producto de polinomios es distributivo respecto de la
--   suma.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_distributiva
--   +++ OK, passed 100 tests.
--   </pre>
prop_distributiva :: Polinomio -> Polinomio -> Polinomio -> Bool

-- | (deriv p x) es la derivada del polinomio p respecto de la variable x;
--   es decir, la lista de monomios de p que contienen la variable x,
--   eliminándola. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deriv (P [M ["u"],M ["x"],M ["x","y"],M ["x","z"]]) "x"
--   1+y+z
--   </pre>
deriv :: Polinomio -> Variable -> Polinomio

-- | Comprueba que la derivada está bien definida.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_deriv_bien_definida
--   +++ OK, passed 100 tests.
--   </pre>
prop_deriv_bien_definida :: Polinomio -> Variable -> Bool

-- | Comprueba que la segunda derivada es nula.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_deriv_deriv
--   +++ OK, passed 100 tests.
--   </pre>
prop_deriv_deriv :: Polinomio -> Variable -> Bool

-- | Comprueba que la derivada de la suma es la suma de las derivadas.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_deriv_suma
--   +++ OK, passed 100 tests.
--   </pre>
prop_deriv_suma :: Polinomio -> Polinomio -> Variable -> Bool

-- | Comprueba que la regla de la derivada del producto
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_deriv_prod
--   +++ OK, passed 100 tests.
--   </pre>
prop_deriv_prod :: Polinomio -> Polinomio -> Variable -> Bool

-- | (tr f) es el polinomio correspondiente a la fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; tr (p ∧ (q ∨ r))
--   p*q+p*q*r+p*r
--   
--   &gt;&gt;&gt; tr (p → p ∨ q)
--   1
--   
--   &gt;&gt;&gt; tr ((p → q) ∨ (q → p))
--   1
--   
--   &gt;&gt;&gt; tr ((p → q) ∨ (q → r))
--   1
--   
--   &gt;&gt;&gt; tr ((p → q) ∨ (r → q))
--   1+p*q*r+p*r
--   </pre>
tr :: FProp -> Polinomio

-- | Comprueba que, para toda fórmula f, (tr f) es un polinomio.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck pro_tr_bien_definida
--   +++ OK, passed 100 tests.
--   </pre>
pro_tr_bien_definida :: FProp -> Bool

-- | (theta2 m) es la fórmula correspondiente al polinomio p según las
--   siguientes reglas:
--   
--   <ul>
--   <li>theta 0 = F</li>
--   <li>theta (a+b) = no ((theta a) ↔ (theta b))</li>
--   </ul>
--   
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; theta (P [mUno])
--   ⊤
--   
--   &gt;&gt;&gt; theta (P [mUno, M ["p"]])
--   ¬(⊤ ↔ p)
--   
--   &gt;&gt;&gt; theta (P [mUno, M ["p"], M ["p","q"]])
--   ¬(⊤ ↔ ¬(p ↔ (p ∧ q)))
--   
--   &gt;&gt;&gt; theta (P [mUno, M ["p"], M ["p","q"],M["p","q","r"]])
--   ¬(⊤ ↔ ¬(p ↔ ¬((p ∧ q) ↔ (p ∧ (q ∧ r)))))
--   
--   &gt;&gt;&gt; theta (P [mUno, M ["p"], M ["p","q"],M["p","q","r"],M["r"]])
--   ¬(⊤ ↔ ¬(p ↔ ¬((p ∧ q) ↔ ¬((p ∧ (q ∧ r)) ↔ r))))
--   </pre>
theta :: Polinomio -> FProp

-- | (theta2 m) es la fórmula correspondiente al monomio m según las
--   siguientes reglas:
--   
--   <ul>
--   <li>theta2 1 = T</li>
--   <li>theta2 (x_i) = p_i</li>
--   <li>theta2 (a*b) = (theta2 a) ∧ (theta2 b)</li>
--   </ul>
--   
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; theta2 (M ["p","q","r"])
--   (p ∧ (q ∧ r))
--   </pre>
theta2 :: Monomio -> FProp

-- | Comprueba que para cualquier fórmula f, (theta (tr f)) es equivalente
--   a f.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_theta_tr
--   +++ OK, passed 100 tests.
--   </pre>
prop_theta_tr :: FProp -> Bool

-- | Comprueba que, para cualquier polinomio p, tr (theta p) es igual a p.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_tr_theta
--   +++ OK, passed 100 tests.
--   </pre>
prop_tr_theta :: Polinomio -> Bool

-- | (derivP f v) es la derivada de la fórmula proposicional f respecto de
--   la variable v. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; derivP (p ∧ q → r) "p"
--   ¬(q ↔ (q ∧ r))
--   
--   &gt;&gt;&gt; derivP (p ∧ q → r) "q"
--   ¬(p ↔ (p ∧ r))
--   
--   &gt;&gt;&gt; derivP (p ∧ q → r) "r"
--   (p ∧ q)
--   
--   &gt;&gt;&gt; derivP (p ∧ q → p ∨ q) "p"
--   ⊥
--   </pre>
derivP :: FProp -> SimboloProposicional -> FProp

-- | (sustituir f v g) es la fórmula obtenida sustituyendo en la fórmula f
--   la variable v por la fórmula g. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; sustituir (p → q ∨ r) "q" (p ∧ q)
--   (p → ((p ∧ q) ∨ r))
--   </pre>
sustituir :: FProp -> SimboloProposicional -> FProp -> FProp

-- | (variablesProp f) es la lista de las variables proposicionales de la
--   fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; variablesProp (p → q ∨ p)
--   ["p","q"]
--   </pre>
variablesProp :: FProp -> [SimboloProposicional]

-- | Comprueba que, para toda fórmula f y toda variable x de f, la derivada
--   de f respecto de x es equivalente a la fórmula ¬(f[x/¬x] ↔ f)
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_derivP_sustituir
--   +++ OK, passed 100 tests.
--   </pre>
prop_derivP_sustituir :: FProp -> Bool

-- | (indep p x) es el polinomio formado por los monomios de que no
--   contienen la variable x. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; indep (P[M["x","y"],M["y","u"],M ["z"]]) "x"
--   y*u+z
--   </pre>
indep :: Polinomio -> Variable -> Polinomio

-- | (delta a1 a2 v) es el polinomio obtenido aplicando la regla delta (o
--   de independencia) a los polinomios a1 y a2 respecto de la variable v;
--   es decir, el polinomio 1 + (1+a1*a2)*(1+a1*c2+a2*c1+c1*c2) donde ci es
--   la derivada de ai respecto de v (para i = 1, 2). Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; delta (P[M["x","y"],M["y","z"]]) (P[M["u","x"],M["y","z"]]) "x"
--   u*y+u*y*z+y*z
--   </pre>
delta :: Polinomio -> Polinomio -> Variable -> Polinomio

-- | (delta' a1 a2 v) es el polinomio 1 + (1+b1*b2)*(1+(b1+c1)*(b2+c2))
--   donde ci es la derivada de ai respecto de v y bi es es el polinomio
--   formado por los monomios de ai que no contienen la variable x (para i
--   = 1, 2). Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; delta' (P[M["x","y"],M["y","z"]]) (P[M["u","x"],M["y","z"]]) "x"
--   u*y+u*y*z+y*z
--   </pre>
delta' :: Polinomio -> Polinomio -> Variable -> Polinomio

-- | Comprueba que las funciones delta y delta' son equivalentes.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_equiv_delta_delta'
--   +++ OK, passed 100 tests.
--   </pre>
prop_equiv_delta_delta' :: Polinomio -> Polinomio -> Bool

-- | (variablesMon m) es la lista de las variables del monomio m. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; variablesMon (M ["x","z"])
--   ["x","z"]
--   </pre>
variablesMon :: Monomio -> [Variable]

-- | (variablesPol p) es la lista de las variables del polinomio p. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; variablesPol (P[M["x","z"],M["y","z"]])
--   ["x","z","y"]
--   </pre>
variablesPol :: Polinomio -> [Variable]

-- | (deltaP f1 f2 v) es la f§ormula obtenida aplicando la regla delta (o
--   de independencia) a las fórmulas f1 y f2 respecto de la variable v.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deltaP (r → p ∨ q) (q → p ∧ q) "q"
--   ¬(⊤ ↔ ¬((p ∧ r) ↔ r))
--   </pre>
deltaP :: FProp -> FProp -> SimboloProposicional -> FProp

-- | Comprueba que la regla delta es adecuada: es decir que, para toda
--   fórmulas f1 y f2 y toda variable x de ellas, la fórmula (deltaP f1 f2
--   x) es consecuencia de f1 y f2.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_adecuacion_deltaP
--   +++ OK, passed 100 tests.
--   </pre>
prop_adecuacion_deltaP :: FProp -> FProp -> Bool

-- | (pares xs) es la lista de los pares de elementos xs con el primero
--   menor o igual que el segundo. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; pares [1..4]
--   [(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,3),(3,4),(4,4)]
--   </pre>
pares :: [a] -> [(a, a)]

-- | (derivadas ps x) es la lista de los polinomios obtenidos aplicando la
--   regla delta a dos polinomios de ps respecto de la variable x. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; derivadas [P[M["x","y"],M["y","z"]],P[M["a","y"],M["y"]]] "y"
--   [x+z,a*x+a*z+x+z,1+a]
--   </pre>
derivadas :: [Polinomio] -> Variable -> [Polinomio]

-- | (derivadasP fs x) es la lista de las proposiciones obtenidas aplicando
--   la regla deltaP a dos fórmulas de fs respecto de la variable x. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; derivadasP [p → q ∨ r, r → p] "q"
--   [¬(⊤ ↔ ¬((p ∧ r) ↔ r))]
--   
--   &gt;&gt;&gt; derivadasP [p → q ∨ r, r → q] "q"
--   []
--   </pre>
derivadasP :: [FProp] -> SimboloProposicional -> [FProp]

-- | (deltaRefutable ps) se verifica si ps es refutable mediante la regla
--   delta. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deltaRefutable [P[mUno,M["p"],M["p","q"]],P[M["p"]],P[mUno,M["q"]]]
--   True
--   
--   &gt;&gt;&gt; deltaRefutable [P[mUno,M["p"],M["p","q"]],P[M["p"]],P[mUno,M["r"]]]
--   False
--   </pre>
deltaRefutable :: [Polinomio] -> Bool

-- | (deltaRefutableP fs) se verifica si fs es refutable mediante la regla
--   delta. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deltaRefutableP [p → q, p, no q]
--   True
--   
--   &gt;&gt;&gt; deltaRefutableP [p → q, p, no r]
--   False
--   </pre>
deltaRefutableP :: [FProp] -> Bool

-- | (deltaRefutableP' fs) se verifica si fs es refutable mediante la regla
--   delta. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deltaRefutableP' [p → q, p, no q]
--   True
--   
--   &gt;&gt;&gt; deltaRefutableP' [p → q, p, no r]
--   False
--   </pre>
deltaRefutableP' :: [FProp] -> Bool

-- | Comprueba que las funciones deltaRefubleP y deltaRefutableP' son
--   equivalentes.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_def_alt_deltaRefutableP
--   +++ OK, passed 100 tests.
--   </pre>
prop_def_alt_deltaRefutableP :: [FProp] -> Bool

-- | Comprueba que la regla delta es adecuada y completa; es decir, para
--   todo conjunto de fórmulas fs, fs es inconsistente si y sólo si es
--   delta refutable.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_adecuacion_completitud_deltaP
--   +++ OK, passed 100 tests.
--   </pre>
prop_adecuacion_completitud_deltaP :: [FProp] -> Bool

-- | (deltaDemostrable fs g) se verifica si g es demostrable a partir de fs
--   usando la regla delta. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deltaDemostrable [p → q, q → r] (p → r)
--   True
--   
--   &gt;&gt;&gt; deltaDemostrable [p → q, q → r] (r → p)
--   False
--   </pre>
deltaDemostrable :: [FProp] -> FProp -> Bool

-- | Comprueba que la regla delta es adecuada y completa; es decir, para
--   todo conjunto de fórmulas fs y toda fórmula g, g es consecuencia de fs
--   si y sólo si es g es delta demostrable a partir de fs.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_adecuacion_completitud_delta_2
--   +++ OK, passed 100 tests.
--   </pre>
prop_adecuacion_completitud_delta_2 :: [FProp] -> FProp -> Bool

-- | (deltaTeorema f) se verifica si f es un teorema mediante la regla
--   delta; es decir, si la negación de f es delta refutable. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deltaTeorema ((p → q) ∨ (q → p))
--   True
--   
--   &gt;&gt;&gt; deltaTeorema ((p → q) ∨ (q → r))
--   True
--   
--   &gt;&gt;&gt; deltaTeorema ((p → q) ∨ (r → q))
--   False
--   </pre>
deltaTeorema :: FProp -> Bool

-- | Comprueba que la regla delta es adecuada y completa; es decir, que
--   para toda fórmula f, f es válida si y sólo si es un delta teorema.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_adecuacion_completitud_delta_3
--   +++ OK, passed 100 tests.
--   </pre>
prop_adecuacion_completitud_delta_3 :: FProp -> Bool
instance GHC.Classes.Ord CLAI2009.Polinomio
instance GHC.Classes.Eq CLAI2009.Polinomio
instance GHC.Classes.Ord CLAI2009.Monomio
instance GHC.Classes.Eq CLAI2009.Monomio
instance GHC.Classes.Ord CLAI2009.FProp
instance GHC.Classes.Eq CLAI2009.FProp
instance GHC.Show.Show CLAI2009.FProp
instance Test.QuickCheck.Arbitrary.Arbitrary CLAI2009.FProp
instance GHC.Show.Show CLAI2009.Monomio
instance Test.QuickCheck.Arbitrary.Arbitrary CLAI2009.Monomio
instance GHC.Show.Show CLAI2009.Polinomio
instance Test.QuickCheck.Arbitrary.Arbitrary CLAI2009.Polinomio
instance GHC.Num.Num CLAI2009.Polinomio
